

## 🧩 一、表连接（JOIN）

| 类型           | 使用时机                           | SQL 示例                               | 典型陷阱               | 代表题目        |
| ------------ | ------------------------------ | ------------------------------------ | ------------------ | ----------- |
| `INNER JOIN` | 只取两表中匹配的记录                     | `FROM A JOIN B ON A.id = B.id`       | 不匹配的记录会丢失          | 181、184     |
| `LEFT JOIN`  | 取左表全部记录，即使右表无匹配也要保留            | `FROM A LEFT JOIN B ON A.id = B.id`  | 需加 `IS NULL` 筛右表空行 | 175、183、577 |
| `RIGHT JOIN` | 和 `LEFT JOIN` 相反（不常用，MySQL 支持） | `FROM A RIGHT JOIN B ...`            | 小众使用，优先考虑 LEFT     | –           |
| `SELF JOIN`  | 同表不同角色（如员工和经理）                 | `FROM E e JOIN E m ON e.mId = m.id`  | `AS` 重命名避免字段冲突     | 181、570     |
| 多次连接         | 表中多字段都需外键关联（如客户和司机）            | `JOIN Users u1 ... JOIN Users u2...` | 字段重名需加前缀或别名        | 262（Trips）  |

---

## 🔍 二、子查询（Subquery）

| 类型                      | 使用时机                     | 示例                                            | 注意点           | 代表题目        |
| ----------------------- | ------------------------ | --------------------------------------------- | ------------- | ----------- |
| 标量子查询                   | 查询结果是单值（用于字段或条件）         | `SELECT ... WHERE salary > (SELECT MAX(...))` | 结果必须是单行       | 176、586     |
| 表子查询                    | 结果为一张表用于 `FROM` 或 `JOIN` | `FROM (SELECT ...) AS t`                      | 需给别名，否则报错     | 184、550     |
| `IN` / `NOT IN`         | 判断是否在集合中                 | `WHERE id NOT IN (SELECT ...)`                | NULL 值会导致匹配失败 | 183、196、585 |
| `EXISTS` / `NOT EXISTS` | 判断子查询是否至少有一行             | `WHERE EXISTS (SELECT 1 FROM ...)`            | 更安全处理 NULL    | 182、183     |

✅ **技巧对比**：

* `IN` 查询快于 `EXISTS`，但对 NULL 敏感。
* `EXISTS` 更适合大数据过滤（尤其有索引时）。

---

## 📊 三、分组与聚合（GROUP BY / HAVING）

| 聚合函数                    | 使用说明               | 示例                     | 易错点                       | 代表题目        |
| ----------------------- | ------------------ | ---------------------- | ------------------------- | ----------- |
| `GROUP BY`              | 按字段分组，后续只能用聚合或分组字段 | `GROUP BY dept_id`     | 与 SELECT 字段必须匹配           | 184、596、586 |
| `HAVING`                | 对聚合结果进行筛选          | `HAVING COUNT(*) >= 5` | 不要写成 `WHERE COUNT(*) ...` | 596、570     |
| `COUNT(*)`              | 统计行数               | `COUNT(*)`             | 不会忽略 NULL                 | 多数题目        |
| `COUNT(DISTINCT x)`     | 去重统计               | `COUNT(DISTINCT name)` | 仅用于 MySQL / PostgreSQL    | 596、550     |
| `SUM(...)`              | 累加求和               | `SUM(salary)`          | 不会自动去重                    | 585         |
| `MAX(...)` / `MIN(...)` | 极值                 | `MAX(salary)`          | 忽略 NULL                   | 177、184、511 |

---

## ⏱ 四、排序与限制（ORDER BY / LIMIT）

| 用法                      | 示例                     | 注意事项          | 代表题目    |
| ----------------------- | ---------------------- | ------------- | ------- |
| `ORDER BY col ASC/DESC` | `ORDER BY salary DESC` | 默认升序，记得指定排序方向 | 178、620 |
| `LIMIT n`               | `LIMIT 1`              | 返回前 n 行       | 176、586 |
| `LIMIT 1 OFFSET n`      | `LIMIT 1 OFFSET 2`     | 返回第 n+1 行     | 177     |

✅ **实际技巧**：

* 可结合子查询定位第 N 名：`LIMIT 1 OFFSET n-1`。
* `LIMIT + OFFSET` 性能较差（全扫描），`DENSE_RANK()` 更高效。

---

## 🪟 五、窗口函数（Window Functions）

| 函数              | 功能         | 示例                                    | 特点               | 代表题目    |
| --------------- | ---------- | ------------------------------------- | ---------------- | ------- |
| `RANK()`        | 有并列排名（跳号）  | `RANK() OVER (...)`                   | 1,1,3            | 178     |
| `DENSE_RANK()`  | 有并列排名（不跳号） | `DENSE_RANK() OVER (...)`             | 1,1,2            | 185、184 |
| `ROW_NUMBER()`  | 行唯一编号（无并列） | `ROW_NUMBER() OVER (...)`             | 1,2,3            | 601（间接） |
| `LAG(x, n)`     | 向前取第 n 行   | `LAG(score, 1) OVER (...)`            | 可组合比较前几天数据       | 180、197 |
| `LEAD(x, n)`    | 向后取第 n 行   | `LEAD(student) OVER (...)`            | 常用于行列互换等场景       | 626     |
| `FIRST_VALUE()` | 返回分区内第一条值  | `FIRST_VALUE(date) OVER (...)`        | 保留原始行结构          | 511     |
| `PARTITION BY`  | 按组分区窗口计算   | `OVER(PARTITION BY dept ORDER BY...)` | 类似 GROUP BY + 排名 | 多题涉及    |

✅ **实践建议**：

* 窗口函数不会压缩记录，适合原行保留逻辑。
* 对性能较敏感的查询使用 `RANK()` 等避免嵌套。

---

## 🔁 六、更新与删除（UPDATE / DELETE）

| 类型                        | 使用场景         | 示例                                     | 代表题目 |
| ------------------------- | ------------ | -------------------------------------- | ---- |
| `UPDATE`                  | 更新字段         | `SET sex = CASE WHEN ... THEN ... END` | 627  |
| `DELETE ... JOIN`         | 删除匹配某条件的重复记录 | `DELETE p1 FROM P p1 JOIN P p2 ...`    | 196  |
| `DELETE ... WHERE NOT IN` | 删除非主记录       | `WHERE Id NOT IN (SELECT MIN(...))`    | 196  |

✅ **注意点**：

* MySQL 允许 `DELETE` 多表连接，其他数据库需分步处理。
* 更新布尔字段常使用 `CASE` 或 `IF()` 简洁表达。

---

## 🧮 七、日期与数学函数

| 函数 / 表达式                 | 功能            | 示例                                | 应用题目        |
| ------------------------ | ------------- | --------------------------------- | ----------- |
| `DATEDIFF(date1, date2)` | 两日期差值（天）      | `DATEDIFF(a.event_date, b.first)` | 550、197     |
| `ROUND(x, n)`            | 保留小数点 n 位     | `ROUND(1.2345, 2)`                | 262、550、585 |
| `MOD(id, 2)` 或 `%`       | 判断奇偶          | `id % 2 = 1`                      | 620、626     |
| `COALESCE(a, b)`         | 返回第一个非 NULL 值 | `COALESCE(lead(x), x)`            | 626         |

---

## 📋 八、其他技巧/高频考点

| 技巧                      | 功能说明            | 示例 / 注意事项                         | 应用题目        |
| ----------------------- | --------------- | --------------------------------- | ----------- |
| `DISTINCT`              | 去除重复记录          | `SELECT DISTINCT salary`          | 176、177     |
| `(col1, col2) IN (...)` | 多字段复合匹配         | `(deptId, salary) IN (SELECT...)` | 184         |
| `WITH`（CTE）             | 公共表达式提升可读性      | `WITH t AS (SELECT...)`           | 262、585、601 |
| 多表多次使用                  | 连接同一张表两次，使用别名区分 | 客户 / 司机过滤、经理 / 员工                 | 262、181     |

---

## 🧠 九、典型 SQL 思维模型（题型归纳）

| 题型          | 解决方案（关键词）                                          | 代表题目        |
| ----------- | -------------------------------------------------- | ----------- |
| 查找未匹配（从未下单） | `LEFT JOIN + IS NULL` / `NOT EXISTS`               | 183、584     |
| 查找重复值       | `GROUP BY + HAVING COUNT(*) > 1` / `EXISTS`        | 182、196     |
| 查找连续记录      | `LAG` + 比较 / `ROW_NUMBER 差分分组`                     | 180、601     |
| 查找第 N 高     | `LIMIT + OFFSET` / `DENSE_RANK()`                  | 176、177、185 |
| 次日登录/行为追踪   | `JOIN first_login + DATEDIFF = 1`                  | 550         |
| 分组极值匹配      | `(group_id, value) IN (SELECT group_id, MAX(val))` | 184、185     |
| 多重聚合组合匹配    | `JOIN + GROUP + PARTITION BY`                      | 585、586     |


